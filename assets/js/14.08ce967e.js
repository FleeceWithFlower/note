(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{198:function(t,s,n){"use strict";n.r(s);var a=n(0),e=Object(a.a)({},function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("1.Class")]),t._v(" "),n("p",[t._v("定义类")]),t._v(" "),n("p",[t._v("构造函数的另一种写法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }//构造函数\n \n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }//添加原型方法\n}\n")])])]),n("p",[t._v("Object.assign")]),t._v(" "),n("p",[t._v("可以很方便地一次向类添加多个方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Point {\n  constructor(){\n    // ...\n  }\n}//构造函数\n \n \nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});//添加多个原型方法\n")])])]),n("p",[t._v("特点：")]),t._v(" "),n("p",[t._v("类的内部所有定义的方法，都是不可枚举的")]),t._v(" "),n("p",[t._v("2.constructor")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Object.getPrototypeOf(obj)//获取实例原型\n3.set get\nclass Point {\n  constructor(){\n    // ...\n  }\nget var() {\n      }//设置访问器属性 var 的get方法\n \n  set var() {\n      }//设置访问器属性 var 的set方法\n}\n")])])]),n("p",[t._v("Class 表达式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let person = new class { constructor() { }//构造函数}（’参数’） person.sayName()\n")])])]),n("p",[n("strong",[t._v("特点：")])]),t._v(" "),n("p",[n("strong",[t._v("不存在提升")])]),t._v(" "),n("p",[n("strong",[t._v("name")]),t._v(" "),n("strong",[t._v("属性")])]),t._v(" "),n("h2",{attrs:{id:"静态方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#静态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 静态方法")]),t._v(" "),n("p",[t._v("如果在一个方法前，加上"),n("code",[t._v("static")]),t._v("关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。")])])},[],!1,null,null,null);s.default=e.exports}}]);
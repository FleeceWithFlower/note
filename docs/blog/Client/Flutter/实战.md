# [Flutter实战](https://book.flutterchina.club/chapter2/flutter_package_mgr.html)

## 第二章

### 路由管理

- `MaterialPageRoute`

  `MaterialPageRoute`继承自`PageRoute`类，`PageRoute`类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。

  ```dart
  MaterialPageRoute({
      WidgetBuilder builder,//我们通常要实现此回调，返回新路由的实例
      RouteSettings settings,//包含路由的配置信息
      bool maintainState = true,//是否释放内存
      bool fullscreenDialog = false,//是否是一个全屏的模态对话框
    })
  ```

- `Navigator`

  `Navigator`是一个路由管理的组件，它提供了打开和退出路由页方法。

- `push`

  入栈

  ```
  //Future push(BuildContext context, Route route)
  Navigator.push(BuildContext context,
  	 MaterialPageRoute(builder: (context) {
  	 	return NewRoute();
  }));
  ```

- `pop`

  出栈

  ```
  //bool pop(BuildContext context, [ result ])
  ```

### 包管理

Flutter项目默认的配置文件是`pubspec.yaml`

```yaml
name: flutter_in_action #应用或包名称。
description: First Flutter application. #应用或包的描述、简介

version: 1.0.0+1 #版本号

dependencies: #应用或包依赖的其它包或插件
  flutter:
    sdk: flutter
  cupertino_icons: ^0.1.2	

dev_dependencies: #开发环境依赖的工具包
  flutter_test:
    sdk: flutter

flutter: #flutter相关的配置选项
  uses-material-design: true
```

- 安装包

  ```
  flutter packages get
  ```

### 资源管理

```yaml
flutter:
  assets:
    - assets/my_icon.png
    - assets/background.png
```

- 加载图片

  ```dart
  Widget build(BuildContext context) {
    return Image.asset('graphics/background.png');
  }
  ```

### 调试

- `debugger`

  ```dart
  import 'dart:developer';
  void someFunction(double offset) {
    debugger(when: offset > 30.0);
    // ...
  }
  ```

- ### `print`

  打印

- ### `debugPrint`

  打印很多数据

- `assert`

  在Flutter应用调试过程中，Dart `assert`语句被启用，并且Flutter框架使用它来执行许多运行时检查来验证是否违反一些不可变的规则。要关闭调试模式并使用发布模式，请使用`flutter run --release`运行您的应用程序。

### 异常捕获

- `try/catch/finally`

- 错误处理

  ```
  void collectLog(String line){
      ... //收集日志
  }
  void reportErrorAndLog(FlutterErrorDetails details){
      ... //上报错误和日志逻辑
  }
  
  FlutterErrorDetails makeDetails(Object obj, StackTrace stack){
      ...// 构建错误信息
  }
  
  void main() {
    FlutterError.onError = (FlutterErrorDetails details) {
      reportErrorAndLog(details);
    };
    runZoned(
      () => runApp(MyApp()),
      zoneSpecification: ZoneSpecification(
        print: (Zone self, ZoneDelegate parent, Zone zone, String line) {
          collectLog(line); // 收集日志
        },
      ),
      onError: (Object obj, StackTrace stack) {
        var details = makeDetails(obj, stack);
        reportErrorAndLog(details);
      },
    );
  }
  ```

## 第三章

### Widget

Widget的功能是“描述一个UI元素的配置数据”，Flutter中真正代表屏幕上显示元素的类是`Element`

### StatelessWidget

用于不需要维护状态的场景

### Context

`build`方法有一个`context`参数，它是`BuildContext`类的一个实例，表示当前widget在widget树中的上下文。它提供了从当前widget开始向上遍历widget树以及按照widget类型查找父级widget的方法。

### StatefulWidget

`createState()` 用于创建和Stateful widget相关的状态

### State

一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态

- widget

  它表示与该State实例关联的widget实例

- context

  StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。

#### State生命周期

- `initState`

  当Widget第一次插入到Widget树时会被调用

- `didChangeDependencies`

  当State对象的依赖发生变化时会被调用

- `build`

  用于构建Widget子树,会在如下场景被调用

  1. 在调用`initState()`之后。
  2. 在调用`didUpdateWidget()`之后。
  3. 在调用`setState()`之后。
  4. 在调用`didChangeDependencies()`之后。
  5. 在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。

- `reassemble`

  开发模式

- `didUpdateWidget`

  在widget重新构建时

- `deactivate`

  当State对象从树中被移除时。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用`dispose()`方法。

- `dispose`

  当State对象从树中被永久移除时调用；通常在此回调中释放资源。

### Flutter SDK内置组件库

#### Material

Android默认的视觉风格

```
import 'package:flutter/widgets.dart';
```

#### Cupertino

iOS视觉风格

### 文本及样式

#### Text

用于显示简单样式文本

- `textAlign`

- `maxLines`

- `overflow`

- `TextStyle`

  用于指定文本显示的样式

  ```dart
    style: TextStyle(
      color: Colors.blue,  //颜色
      fontSize: 18.0,	//字体大小
      height: 1.2,  //行高	具体的行高等于fontSize*height
      fontFamily: "Courier", // 字体
      background: new Paint()..color=Colors.yellow	//背景色
    ),
  ```

- `TextSpan`

  Text的所有文本内容只能按同一种样式，如果我们需要对一个Text内容的不同部分按照不同的样式显示，这时就可以使用`TextSpan`

- `DefaultTextStyle`

  如果在Widget树的某一个节点处设置一个默认的文本样式，那么该节点的子树中所有文本都会默认使用这个样式

#### 字体

```
flutter:
  fonts:
    - family: Raleway
      fonts:
        - asset: assets/fonts/Raleway-Regular.ttf
        - asset: assets/fonts/Raleway-Medium.ttf
          weight: 500
        - asset: assets/fonts/Raleway-SemiBold.ttf
          weight: 600
```

```
// 声明文本样式
const textStyle = const TextStyle(
  fontFamily: 'Raleway',
);

// 使用文本样式
var buttonText = const Text(
  "Use the font for this text",
  style: textStyle,
);
```

#### Package中的字体

```
const textStyle = const TextStyle(
  fontFamily: 'Raleway',
  package: 'my_package', //指定包名
);
```

### 按钮

- `RaisedButton`

  默认带有阴影和灰色背景。按下后，阴影会变大

- `FlatButton`

  默认背景透明并不带阴影。按下后，会有背景色

- `OutlineButton`

  默认有一个边框，不带阴影且背景透明。

- `IconButton`

  一个可点击的Icon，不包括文字，默认没有背景，点击后会出现背景

### 图片

- 本地图片

  ```
  //根目导导入 images目录
  
  flutter:
    assets:
      - images/bg.jpg
  ```

  ```
            Image(image: AssetImage("images/bg.jpg"), width: double.infinity),
            Image.asset("images/avatar.png",width: 100.0),//快捷方式
  ```

- #### 网络图片

  ```
  Image(
    image: NetworkImage(
        "https://avatars2.githubusercontent.com/u/20411648?s=460&v=4"),
    width: 100.0,
  ),
  Image.network(
    "https://avatars2.githubusercontent.com/u/20411648?s=460&v=4",
    width: 100.0,
  ),//快方构造函数
  ```

- 属性

  ```
  const Image({
    ...
    this.width, //图片的宽
    this.height, //图片高度
    this.color, //图片的混合色值
    this.colorBlendMode, //混合模式
    this.fit,//缩放模式
    this.alignment = Alignment.center, //对齐方式
    this.repeat = ImageRepeat.noRepeat, //重复方式
    ...
  })
  ```

- `ICON`

  ```
  //默认包含了一套Material Design的字体图标
  flutter:
    uses-material-design: true
  ```

  ```
   Icon(Icons.accessible,color: Colors.green,),
  ```

### 单选开关和复选框

- `Switch`

  ```
          Switch(
            value: _switchSelected,//当前状态
            onChanged:(value){
              //重新构建页面
              setState(() {
                _switchSelected=value;
              });
            },
          ),
  
  ```

- `Checkbox`

  ```
  Checkbox(
    value: _checkboxSelected,
    activeColor: Colors.red, //选中时的颜色
    onChanged:(value){
      setState(() {
        _checkboxSelected=value;
      });
    } ,
  )
  ```

它们本身不会保存当前选中状态，选中状态都是由父组件来管理的

### 输入框及表单

#### TextField

```
          TextField(
            autofocus: true,
            decoration: InputDecoration(
                labelText: "用户名",
                hintText: "用户名或邮箱",
                prefixIcon: Icon(Icons.person)
            ),
          ),
```

#### Form

Flutter提供了一个`Form` 组件，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存。

- `Form`

  ```
  autovalidate //是否自动校验输入内容
  onChanged //内容发生变化时会触发此回调
  ```

- `FormField`

  ```
  onSaved	//保存回调
  validator	//验证回调
  initialValue	//初始值
  autovalidate 	//是否自动校验。
  ```

- `TextFormField`

  为了方便使用，Flutter提供了一个`TextFormField`组件，它继承自`FormField`类，除了`FormField`定义的属性之外，它还包括`TextField`的属性

- `FormState`

  ```
  validate	//验证
  save	//调用此方法后，会调用Form子孙FormField的save回调，用于保存表单内容
  reset	//调用此方法后，会将子孙FormField的内容清空。
  ```

### 进度指示器

- `LinearProgressIndicator`

  ```
            LinearProgressIndicator(
              backgroundColor: Colors.grey[200],
              valueColor: AlwaysStoppedAnimation(Colors.blue),
              value: .5,
            ),//进度条显示50%
  
  ```

  

- `CircularProgressIndicator`

  ```
            CircularProgressIndicator(
              backgroundColor: Colors.grey[200],
              valueColor: AlwaysStoppedAnimation(Colors.blue),
              value: .5,
            ),
  
  ```

## 第四章

#### 布局类组件简介

`Element`树才是最终的绘制树，`Element`树是通过Widget树来创建的（通过`Widget.createElement()`），Widget其实就是Element的配置数据。

在Flutter中，根据Widget是否需要包含子节点将Widget分为了三类

| Widget                        | 对应的Element                  | 用途                                       |
| ----------------------------- | ------------------------------ | ------------------------------------------ |
| LeafRenderObjectWidget        | LeafRenderObjectElement        | Widget树的叶子节点，用于没有子节点的widget |
| SingleChildRenderObjectWidget | SingleChildRenderObjectElement | 包含一个子Widget                           |
| MultiChildRenderObjectWidget  | MultiChildRenderObjectElement  | 包含多个子Widget，一般都有一个children参数 |

#### 线性布局

所谓线性布局，即指沿水平或垂直方向排布子组件，Row`和`Column`都继承自`Flex

- 主轴和纵轴

  对于线性布局，有主轴和纵轴之分，如果布局是沿水平方向，那么主轴就是指水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。

- ##### `Row`

  - `textDirection`

    水平方向

    ```
    ltr	//左向右
    rtl //右向左
    ```

    

  - `verticalDirection`

    纵轴的对齐方向

    ```
    up //由上至下
    down //由下至上
    ```

  - `mainAxisSize`

    `Row`在主轴(水平)方向占用的空间

    ```
    //MainAxisSize.max	尽可能多的占用水平方向的空间	默认值
    //MainAxisSize.min	尽可能少的占用水平空间
    ```

  - `mainAxisAlignment`

    水平空间内对齐方式

    ```
    MainAxisAlignment.start	//起始
    MainAxisAlignment.end	//末尾
    MainAxisAlignment.center	//居中
    ```

  - crossAxisAlignment

    子组件在纵轴方向的对齐方式

    ```
    MainAxisAlignment.start	//起始
    MainAxisAlignment.end	//末尾
    MainAxisAlignment.center	//居中
    ```

    

- `Column`

  参数和`Row`一样，不同的是布局方向为垂直，主轴纵轴正好相反

#### 弹性布局（Flex）

- `Expanded`

  可以按比例扩伸 `Row`、`Column`和`Flex`子组件所占用的空间。

  ```
  flex	//如果为0或null，则child是没有弹性的
  ```

  ```dart
  Expanded(
    flex: 1,
    child: Container(
    height: 30.0,
    color: Colors.red))
  ```

#### 流式布局

Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误,Wrap`和`Flow会自动折行

- `Wrap`

  - `spacing`：主轴方向子widget的间距
  - `runSpacing`：纵轴方向的间距
  - `runAlignment`：纵轴方向的对齐方式

- `Flow`

  

#### 层叠布局

Flutter中使用`Stack`和`Positioned`这两个组件来配合实现绝对定位。`Stack`允许子组件堆叠，而`Positioned`用于根据`Stack`的四个角来确定子组件的位置。

- `Stack`

  

- `Positioned`

  ```
  left、top 、right、 bottom
  ```

  

#### 对齐与相对定位

- `Align`

  `widthFactor`和`heightFactor`是用于确定`Align` 组件本身宽高的属性；它们是两个缩放因子，会分别乘以子元素的宽、高，最终的结果就是`Align` 组件的宽高。如果值为`null`，则组件的宽高将会占用尽可能多的空间。

- `Alignment`

  ```
  (Alignment.x*childWidth/2+childWidth/2, Alignment.y*childHeight/2+childHeight/2)
  ```

  

- `FractionalOffset`

  ```
  实际偏移 = (FractionalOffse.x * childWidth, FractionalOffse.y * childHeight)
  ```

## 第五章 容器类组件

容器类Widget一般只需要接收一个子Widget（child），只是包装其子Widget，对其添加一些修饰（补白或背景色等）、变换(旋转或剪裁等)、或限制(大小等)

### Padding

`Padding`可以给其子节点添加填充（留白）

```
Padding(
         padding: EdgeInsets.all(16.0),
         child: Text("padding"),
)
```

### 尺寸限制类容器

尺寸限制类容器用于限制容器大小

- `ConstrainedBox`

  ```
  ConstrainedBox(
    constraints: BoxConstraints(
      minWidth: double.infinity, //宽度尽可能大
      minHeight: 50.0 //最小高度为50像素
    ),
    child: Container(
        height: 5.0, 
        child: redBox 
    ),
  )
  ```

### 装饰容器

- `DecoratedBox`

  `DecoratedBox`可以在其子组件绘制前(或后)绘制一些装饰（Decoration），如背景、边框、渐变等

  - `decoration`

  ```
  BoxDecoration({
    Color color, //颜色
    DecorationImage image,//图片
    BoxBorder border, //边框
    BorderRadiusGeometry borderRadius, //圆角
    List<BoxShadow> boxShadow, //阴影,可以指定多个
    Gradient gradient, //渐变
    BlendMode backgroundBlendMode, //背景混合模式
    BoxShape shape = BoxShape.rectangle, //形状
  })
  ```

### Container

`Container`是一个组合类容器	

```
padding
margin
color
```

###  Scaffold、TabBar、底部导航

#### Scaffold

```
导航栏
抽屉
底部导航
悬浮的动作按钮
```

### 剪裁（Clip）

```
ClipOval(child: avatar) //圆形
```

## 第六章 可滚动组件

### SingleChildScrollView

### ListView

- `ListTile`

- `ListView.builder`

  ```
  itemBuilder	//它是列表项的构建器
  itemCount	//列表项的数量
  ```

### GridView

### CustomScrollView

### ScrollController

控制可滚动组件的滚动位置

## 第七章 功能型组件

## 第八章  事件

- `Listener`
- `GestureDetector`
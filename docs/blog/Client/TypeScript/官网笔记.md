​	

# typescript

## 基础类型

### 布尔值

```
let isDone: boolean = false;
```

### 数字

```
let decLiteral: number = 6;
```

### 字符串

```
let name: string = "bob";
```

### 数组

```
let list: number[] = [1, 2, 3];
```

- 只读数组

```
let ro: ReadonlyArray<number> = a;
```

### 元组

```
let x: [string, number]= ['1', 2];
```

### 枚举

```
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
```

### Any

> 不确定类型，直接通过检查

```
let notSure: any = 4;
let list: any[] = [1, true, "free"];
```

### Void

> 获函数返回为空，或只能赋予`undefined`和`null`

```
function warnUser(): void {
    console.log("This is my warning message");
}
let unusable: void = undefined;
```

### Null 和 Undefined

```
let u: undefined = undefined;
let n: null = null;
```

### Never

> `never`类型表示的是那些永不存在的值的类型。如抛出异常 

```
function error(message: string): never {
    throw new Error(message);
}
```

### Object

> `object`表示非原始类型,除`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型

### 类型断言

> 程序员标注变量类型

```
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
```

## 接口

### interface

​	声明数据结构

```
interface LabelledValue {  label: string; } 
```

### 函数类型

```
interface SearchFunc {
  (source: string, subString: string): boolean;
}
```

### 可索引的类型

​	当用 `number`去索引`StringArray`时会得到`string`类型的返回值

```
interface StringArray {
  [index: number]: string;
}
```

### 类

```
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
```

## 类

### 继承

```
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}
```

 `Dog`是一个 *派生类*，它派生自 `Animal` *基类*，通过 `extends`关键字。 派生类通常被称作 *子类*，基类通常被称作 *超类*

### public

​	公有成员

### private

​	私有成员

### protected

​	同`private`类似，但是在派生类中可以引用。

### readonly

​	只读成员，类外不能更改

```
class Octopus {
    readonly name: string;
    constructor (theName: string) {
        this.name = theName;
    }
}
```

### 存取器

- get
- set

### 静态属性

```
class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin() {
    	return Grid.origin+this.scale;
    }
    constructor (public scale: number) { }
}
```

### 抽象类

抽象类做为其它派生类的基类使用。`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法。

```
abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log('roaming the earch...');
    }
}
class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}
let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
```


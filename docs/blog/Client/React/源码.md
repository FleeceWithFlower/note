### 

### 设计原则

### Shadow DOM

```
Shadow DOM 是一种浏览器技术，主要用于在 web 组件中封装变量和 CSS。
```



### Virtual DOM

```
Virtual DOM 则是一种由 Javascript 类库基于浏览器 API 实现的概念。
```

####  [fibers](https://github.com/acdlite/react-fiber-architecture)( 纤维 )

- 什么是`fibers`

```
Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染。
React Fiber的目标是提高其对动画，布局和手势等区域的适用性。
React 也使用一个名为 “fibers” 的内部对象来存放组件树的附加信息,
A fiber represents a unit of work.	//纤维代表工作单位
```

- 目的/解决问题

```
Fiber是堆栈的重新实现，您可以将堆栈帧保留在内存中，并根据需要（以及在任何时候）执行它们。
除了调度之外，手动处理堆栈帧还可以释放诸如并发和错误边界之类的功能。
```

- #### `type` and `key`

  `type`用于堆栈框架追踪谁正在执行，对于复合组件，`type` 是函数或类组件本身 ，而 host components (`div`, `span`, etc.)，`type`是一个字符串。
   key  用来决定 是否可以重用`fibers`

- #### `child`and`sibling`

   这些字段指向其他纤维，描述了纤维的递归树结构。 
   
- #### `return`

   返回当前`fiber`执行后应该执行的`fiber`。

- #### `pendingProps` and `memoizedProps`

    `fiber` 的 `pendingProps` 赋值在`fiber `执行前， `memoizedProps`  赋值在`fiber `执行后，当` pendingProps `和` memoizedProps `相等时，表示可以使用`memoizedProps`先前的输出结果， 从而避免了不必要的工作。 

- #### `pendingWorkPriority`

    一个数字，代表`fiber`工作的优先级，除了` NoWork `为0，数字越大优先级越低。

- `alternate`（ 替换物 ）

   -  *flush* 

     flush一个`fiber`给渲染器， 将其输出渲染到屏幕上 

   - `work-in-progress`

#### incremental rendering(增量式渲染)

###  [Reconciliation](https://facebook.github.io/react/docs/reconciliation.html) ( 协调 )（DIFF算法）

- 什么是`reconciliation`

```
React使用该算法将一棵树与另一棵树进行比较，以确定哪些部分需要更改。

A high-level description goes something like this: when you render a React application, a tree of nodes that describes the app is generated and saved in memory. This tree is then flushed to the rendering environment — for example, in the case of a browser application, it's translated to a set of DOM operations. When the app is updated (usually via setState), a new tree is generated. The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app.
```

:::tip

Reconciliation versus rendering(协调与渲染)

```
DOM只是React可以渲染的渲染环境之一，其他如 React Native。
React被设计为 协调 和 渲染 是 独立的。
reconciler(协调器) 负责计算树的哪些部分已更改。
renderer(渲染器) 使用上述信息来实际更新渲染的应用程序。
这种分离意味着React DOM和React Native可以使用自己的渲染器，同时共享由React core提供的相同协调器。
```

:::







### Scheduling( 调度 )

### [React - Basic Theoretical Concepts(基本理论概念)](https://github.com/reactjs/react-basic)

:::tip

####  push-based approach(单播)

需要`app`去决定调度工作

 pull-based approach(多播)

更智能，调度工作取决于你。及何时使用 `setState`

:::

#### [Memoization](https://github.com/reactjs/react-basic#memoization)

```
如果我们知道该函数是纯函数，则一遍又一遍地调用同一函数是浪费的。我们可以创建函数的记忆版本，以跟踪最后一个参数和最后一个结果。
```
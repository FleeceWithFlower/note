https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#spring-core

## 1. IoC容器

###  1.1。Spring IoC容器和Bean简介

1. `org.springframework.beans`和`org.springframework.context`包是Spring框架的IoC容器的基础
2. `BeanFactory`为顶层接口，提供了配置框架和基本功能
3. `org.springframework.context.ApplicationContext`是其子接口，增加了更多针对企业的功能
4. 由Spring IoC容器管理的对象称为bean

### 1.2。容器概述

1. `org.springframework.context.ApplicationContext`接口代表Spring IoC容器，并负责实例化，配置和组装Bean。

#### 1.2.1配置元数据

1. 配置元数据用来告诉Spring容器如何实例化，配置和组装应用程序中的对象。
2. 传统上，配置元数据以简单直观的XML格式提供，其他配置注释配置，java代码配置。	

基本配置结构

```
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id="..." class="..."/>
</beans>
```

#### 1.2.2。实例化容器

```
ApplicationContext context = new ClassPathXmlApplicationContex  t("services.xml", "daos.xml");
```

#### 1.2.3。使用容器

`ApplicationContext`是一个维护bean定义以及相互依赖的注册表的高级工厂的接口。过使用方法`T getBean(String name, Class<T> requiredType)`，您可以检索bean的实例

```
PetStoreService service = context.getBean("petStore", PetStoreService.class);
```

### 1.3。Bean总览

#### 1.3.1。命名bean

1. bean名称以小写字母开头
2. `name` 属性中指定别名，并用逗号（`,`），分号（`;`）或空格分隔。
3. 在Bean定义之外别名Bean

```
//name为 bean索引 alias为别名
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
```

####  1.3.2。实例化bean

1. 容器本身反射性地调用其构造函数直接创建Bean，某种程度上等同于使用`new`运算符的Java代码

   ```
   <bean id="exampleBean" class="examples.ExampleBean"/>
   ```

2. 工厂方法实例化

   通过静态工厂方法进行]实例化
   
   ```
   <bean id="clientService"  class="examples.ClientService"
factory-method="createInstance"/>
   ```
   

###  1.4。依存关系

####  1.4.1。依赖注入

依赖注入（DI）是一个过程，对象只能通过构造函数参数，工厂方法的参数，构造或创建对象实例后在对象实例上设置的属性来定义其依赖关系

####  1.4.2。依赖性和详细配置

直值

- 基于构造函数的依赖注入

  ```
      <bean id="beanOne" class="x.y.ThingOne">
          <constructor-arg ref="beanTwo"/>
          <constructor-arg ref="beanThree"/>
      </bean>
  ```

- 基于Setter的依赖注入

  ```
  <bean id="exampleBean" class="examples.ExampleBean">
  	 <property name="driverClassName" 	value="com.mysql.jdbc.Driver"/>
  </bean>
  ---
  //p-namespace
  <bean id="exampleBean" 
  	class="examples.ExampleBean"
  	p:driverClassName="com.mysql.jdbc.Driver"
  >
  ---
  //properties
     <property name="properties">
          <value>
              jdbc.driver.className=com.mysql.jdbc.Driver
              jdbc.url=jdbc:mysql://localhost:3306/mydb
          </value>
      </property>
  ---
  //idref
  <bean id="theTargetBean" class="..."/>
  
  <bean id="theClientBean" class="...">
      <property name="targetName">
          <idref bean="theTargetBean"/>
      </property>
  </bean>
  ---
  
  ```

  

对其他Bean的引用

```
//ref
  <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
```

::tip

idref与ref区别

​	使用idref等同于如下，idref只获取实例名称并且提供验证机制。ref则是取实例。

```
<bean id="theTargetBean" class="..." />
<bean id="client" class="...">
    <property name="targetName" value="theTargetBean" />
</bean> 
```

:::

内部bean

```
<bean id="outer" class="...">
    <property name="target">
        <bean class="com.example.Person">
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

1. 内部bean定义不需要定义的ID或名称,不会使用id作为标识符
2. 容器会忽略`scope`创建时的标志
3. 不可能独立地访问内部bean或将它们注入到协作bean中

注入复杂类型

​	映射键或值的值或设置值也可以是以下任意元素：

```xml
bean | ref | idref | list | set | map | props | value | null
```

#### 1.4.3。depends-on

```
<bean id="sysinit" class="SystemInit">  
<bean id="manager" class="CacheManager"  depends-on="sysinit"/>
```

####  1.4.4。lazy-init

​	延迟初始化的bean告诉IoC容器在首次请求时（而不是在启动时）创建一个bean实例

```
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
```

#### 1.4.5。autowire

#### 1.4.6。方法注入

###  1.5。bean作用范围

- singleton

- prototype

  > 多例

- request

  > 将单个bean定义的范围限定为单个HTTP请求的生命周期。

- session

  > 将单个bean定义的范围限定为HTTP的生命周期`Session`

- application

  > 将单个bean定义的作用域限定为的生命周期`ServletContext`

- websocket

  > 将单个bean定义的作用域限定为的生命周期`WebSocket`。

### 1.6。自定义豆的性质

- 生命周期回调

#### 1.6.1。生命周期回调

- 初始化回调

  1. init-method

     ```
     <bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
     ```

  2. 重写   **afterPropertiesSet**

     ```
     @Override
     public void afterPropertiesSet() {}
     ```

  3. 注释

     ```
     @PostConstruct
     public void init() {}
     ```

     

- ##### 销毁回调

  1. destroy-method

     ```
     <bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
     ```

  2. 重写   ****destroy****

     ```
     @Override
     public void destroy() {}
     ```

  3. 注释

     ```
     @PreDestroy
     public void destroy() {}
     ```

### 1.7。Bean定义继承

###  1.8. 容器扩展

### 1.9。基于注释的容器配置

####  1.9.1。`@Required`

​	适用于bean属性setter方法，声明必须依赖

#### 1.9.2。`@Autowired`

​	自动注入

#### 1.9.3。`@Primary`

多个候选对象时，选择主bean

####  1.9.7。`@Resource`

要注入的Bean名称,默认名称是从字段名称或setter方法派生的

```
    @Resource(name="myMovieFinder") 
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
```

#### 1.9.8。`@Value`

用于注入外部属性

```
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }
//catalog.name=MovieCatalog
```

```
public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
```

###  1.10。类路径扫描和托管组件

#### 1.10.1。@Component`和更多

- @Component

  > 任何Spring托管组件的通用构造型

- @Repository

  > 持久层

- @Service

  > 服务层

- @Controller

  > 表示层

- @Scope

  > 范围

###  1.12。基于Java的容器配置

#### 1.12.1。基本概念：`@Bean`和`@Configuration`

​	当使用第三方包时 @Component等注释 不能配置bean，使用@Bean配置

- @Configuration

  > 用于声明配置类

- @Bean

  > 用于声明bean

#### 1.12.5。组成基于Java的配置

##### `@Import`





##  2.资源

